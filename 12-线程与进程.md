# 线程与进程

时间：``

## 1. 介绍

### 进程与线程

- **进程 (Process)**：操作系统进行资源分配的基本单位。一个正在执行的程序实例，拥有独立的内存空间、数据和系统资源
  - 对于操作系统来说，一个任务就是一个进程（Process）
  - 比如，打开一个浏览器就是启动一个浏览器进程，打开 Markdown 就是启动了一个 Md 的进程。
- **线程 (Thread)**：CPU进行任务调度的基本单位。它依附于进程存在，是进程中的一条执行路径。一个进程可以包含多个线程，它们共享进程的全部资源。
  - 在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程
  - 一个进程至少有一个线程

### 并发与并行

- **并发 (Concurrency)**：指系统能够处理多个任务的能力。
  - 在单核CPU上，这意味着CPU通过极快地在不同进程之间进行上下文切换 (Context Switching)，轮流执行每个进程的一小部分。从宏观上看，这些进程像是同时在运行。
  - 单核CPU无法并行
- **并行 (Parallelism)**：指系统能够同时执行多个任务的能力。
  - 这必须依赖多个CPU核心，每个核心在同一时刻可以独立执行一个任务。
  - 一个进程内多线程的处理方式（是并发还是并行）取决于CPU情况

### 多任务的实现方式

- 三种
  - 多进程，每个进程一个线程
  - 一个进程，多线程
  - 多进程 + 多线程
- 多线程的注意事项：
  - 同时执行多个任务时，各个任务之间并非毫无关联，而是需要相互通信和协调 —— 有时，任务 1 必须暂停等待任务 2 完成后才能继续执行，有时，任务 3 和任务 4 又不能同时执行
  - 所以，多进程和多线程的程序的复杂度要远远高于单进程单线程的程序
  - 比起多进程多线程，**在性能和响应性满足要求的前提下（即在情况许可的情况下）**，应始终首选单线程/单进程模型。

---

## 2. 线程介绍

### 线程的状态

创建线程之后，线程并不是始终保持一个状态的，其状态大致如下：

1. **New (新建状态)**
   - 当我们用代码创建一个线程对象后，它就处于新建状态。
   - 此时，操作系统还没有为它分配任何资源，它只是一个存在于内存中的对象，还不能执行任何代码
2. **Runnable (就绪状态)**
   - 当我们调用线程的 start() 方法后，线程就从“新建”进入“就绪”状态。
   - 这时的线程已经拥有了运行所需的所有资源，正在等待操作系统的CPU调度器(Scheduler)分配CPU时间片给它
3. **Running (运行状态)**
   - 当调度器从就绪队列中选择了这个线程，并为它分配了CPU时间片，线程就开始真正地执行它的任务代码。
   - 但CPU时间片通常很短，用完后线程会回到就绪状态，等待下一次调度，这就是所谓的“上下文切换”。
4. **Blocked (阻塞状态)**
   - 线程在运行过程中，如果遇到某些特定条件，会暂时放弃CPU，进入阻塞状态，停止执行。
   - 阻塞状态的线程不会参与CPU的调度，直到导致它阻塞的事件完成，它才会重新回到就绪状态，等待再次被调度。常见的阻塞原因有：
5. **Dead (消亡状态)**
   - 当线程的任务执行完毕，或者因为未捕获的异常而终止时，它就进入了消亡状态
   - 线程的生命周期结束，它所占用的资源会被操作系统回收。一个已经消亡的线程不能被重新启动

### 线程的类型

线程的类型主要是从功能和与主程序关系的角度来划分的

**主线程 vs 子线程**

- **主线程 (Main Thread)**
  - 任何一个程序启动时，都会默认创建一个进程，并在这个进程中自动创建一个线程来执行程序的入口代码（比如Python脚本的第一行或C语言的main函数）。这个初始线程就是主线程。
  - 特点:
    - 它是程序的“起点”和“根”
    - 通常负责创建和管理其他子线程
    - 主线程的结束往往意味着整个程序的结束
- **子线程 (Child Thread / User Thread)**
  - 在主线程中，由我们手动创建的用于执行特定任务的线程
  - 特点: 专门用来分担任务，与主线程并发执行。

**前台线程 vs 守护线程**

- 这是一个非常重要的分类，它决定了子线程如何影响整个程序的生命周期
- **前台线程（Foreground Thread）**
  - 默认创建的子线程都是前台线程
  - 行为: 只要任何一个前台线程还在运行，整个程序（进程）就不会退出。主线程必须等待所有的前台线程执行完毕后才能结束
  - 类比: 你邀请朋友（前台线程）来家里做客，即使你自己（主线程）想睡觉了，也得等所有客人都走了之后才能锁门（程序退出）。
- **守护线程 (Daemon/Background Thread)**:
  - 通过 `thread.setDaemon(True)` 或 `thread.daemon = True` 设置的线程
  - 行为: 守护线程是一种“后台服务”线程，它的生命周期完全依赖于前台线程。当所有的前台线程（包括主线程）都执行完毕后，守护线程会立即被强制终止，无论它自己的任务是否完成
  - 用途: 非常适合执行一些“无关紧要”的后台任务，如日志记录、心跳检测、数据备份等。这些任务在程序退出时可以被安全地中断

---

## 3. 多线程编程

### 线程的创建

### 线程合并

### 线程同步与互斥锁

### Condition 条件变量

### 线程间通信

### 后台线程

---

## 4. 进程

