# 推导式、迭代器和生成器

时间：`2025年10月17日`

## 1. 推导式

### Def of Comprehension

- Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体
- 是一种强大且简洁的语法，适用于生成列表、字典、集合和<mark>生成器</mark>
  -  列表(list)推导式
  -  字典(dict)推导式
  -  集合(set)推导式
  -  元组(tuple)推导式

<mark>推导式可以理解为使用for循环快速创建可迭代对象吗？</mark>

### 列表推导式

**基本语法：**

```python
# 简单
[表达式 for 变量 in 可迭代对象]

# 升级
[表达式 for 变量 in 可迭代对象 if 条件]

# 再升级
[表达式1 if 条件 else 表达式2 for 变量 in 可迭代对象]
```

- 列表生成元素表达式可以是有返回值的函数
- 示例1：

  ```python
  # 过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：

  names = ['Bob', 'Tom', 'alice', 'Jerry', 'Wendy', 'Smith']
  new_names = [name.upper() for name in names if len(name) > 3]
  print(new_names)
  ```

- 示例2：

  ```python
  list2 = [word.title() if word.startswith('p') else word.upper() for word in list1]
  ```

### 其他推导式

- 字典推导式
  - 语法：

    ```python
    {键:值 for 键/值/一起 in collection if 条件}

    # for 循环中使用键、值还是键值一起，取决于当前的情况需求和后面的循环条件
    ```

  - 示例：

    ```python
    # 1. 用键
    {x: x*2 for x in [1,2,3]}

    # 2. 用键和值
    d = {'a':1, 'b':2, 'c':3}
    # 遍历键值对(k, v)，用v作为新键，k作为新值
    {v: k for k, v in d.items() if v > 1}  # 结果：{2:'b', 3:'c'}
    ```

- 集合推导式
  - 语法：还是使用花括号，但是没有键值对

    ```python
    {表达式 for 变量 in 可迭代对象 if 条件}
    ```

---

## 2. 迭代器

### Def of iteration

在 Python 中，给定一个 list 或 tuple，通过 for 循环来遍历这个 list 或 tuple ，这种遍历就是**迭代（iteration）**

- Python 的 for 循环不仅可以用在 list 或tuple 上，还可以作用在其他可迭代对象上。
- <mark>只要是可迭代的对象，无论有没有下标，都是可以迭代的（*这好像是句循环定义的话*）</mark>
- 迭代是 Python 最强大的功能之一，是访问集合元素的一种方式

### 迭代器及其函数

- **迭代器（iterator）** 是一个可以记住遍历的位置的对象
- 特点：
  - 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束
  - 迭代器只能往前不会后退
  - 字符串，列表或元组对象都可用于创建迭代器
- 两个基本函数
  - `iter()`：`iter(iterable)`
    - 从一个可迭代对象（如列表、字符串）那里，获取一个迭代器；
    - 接收一个可迭代对象（iterable）作为参数，并返回一个迭代器对象
  - `next()`：`next(iterator)`
    - 从迭代器中取出下一个元素
    - 接收一个迭代器对象作为参数，返回该迭代器指向的下一个元素
- 对于一个迭代器对象，你有两种方法可以从中取出所有元素：  
  - **手动**：一次一次地调用 next() 函数，直到取完为止自动挡：把迭代器直接扔进一个 for 循环，让 for 循环自动帮你处理
  - **自动**：把迭代器直接扔进一个 for 循环，让 for 循环自动帮你处理 = for 循环就是 `next()` 函数的一种更高级、更方便、更安全的自动化封装（for 循环的底层工作原理是基于 `iter()` 和 `next()` 的）
- 示例：

  ```python
  # 1. 创建一个可迭代对象（列表）
  my_list = ['apple', 'banana', 'cherry']

  # 2. 使用 iter() 从可迭代对象中获取一个迭代器
  my_iterator = iter(my_list)

  print(f"迭代器的类型是: {type(my_iterator)}")
  # 输出: 迭代器的类型是: <class 'list_iterator'>

  # 3. 使用 next() 从迭代器中逐个获取元素
  print(next(my_iterator))  # 输出: apple
  print(next(my_iterator))  # 输出: banana
  print(next(my_iterator))  # 输出: cherry

  # 4. 再次调用 next()，因为已经没有元素了，所以会触发 StopIteration 异常
  try:
      print(next(my_iterator))
  except StopIteration:
      print("迭代结束，没有更多的元素了！")
  # 输出: 迭代结束，没有更多的元素了！
  ```

### 迭代的特殊方法

- **反向迭代**：使用内置函数 `reversed()`
  - 注意：反向迭代仅仅当对象的大小可预先确定或者<mark>对象实现了 `__reversed__()` 的特殊方法时才能生效。 如果两者都不符合，那你必须先将对象转换为一个列表才行</mark>
  - 示例：

    ```python
    list1 = [1,2,3,4,5]
    for num1 in reversed(list1) :
        print ( num1 , end = ' ' )
    ```

- **同时迭代多个序列**：同时迭代多个序列，每次分别从一个序列中取一个元素
  - 使用 `zip()` 函数：zip(a, b) 会生成一个可返回元组 (x, y) 的迭代器，其中 x 来自 a，y 来自 b。 一旦其中某个序列到底结尾，迭代宣告结束。 因此迭代长度跟参数中最短序列长度一致
  - 示例：

    ```python
    names = ['A', 'B', 'C']
    ages = [18, 19, 20]

    for name, age in zip(names, ages):
        print(name,age)
    ```

  - 输出结果

    ```
    A 18
    B 19
    C 20
    ```

  - 还可把一个 key 列表和一个 value 列表生成一个 dict （字典），如下：

    ```python
    names = ['A', 'B', 'C']
    ages = [18, 19, 20]

    dict1= dict(zip(names,ages))

    print(dict1)
    ```

  - 输出结果

    ```
    {'A': 18, 'B': 19, 'C': 20}
    ```

---

## 3. 生成器

### Intro

- 已知列表生成式，可以直接创建一个列表；但是，受到内存限制，列表容量是有限的。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的 list，从而节省大量的空间。
- 这种一边循环一边计算的机制，被称为**生成器（generator）**
  - 或者，使用了 `yield` 的函数被称为生成器（generator）
  - 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作
  - 更简单地理解，生成器也是一种迭代器，但是**只能对其迭代一次**；这是因为它们并没有把所有的值存在内存中，而是在运行时生成值
  - <mark>在调用生成器运行的过程中，每次遇到 `yield` 时函数会暂停并保存当前所有的运行信息，返回 `yield` 的值。并在下一次执行 `next()` 方法时从当前位置继续运行</mark>
- 生成器表达式使用了“惰性计算”（lazy evaluation）；只有在检索时才被赋值（ evaluated ），所以在列表比较长的情况下使用内存上更有效。

### 生成器的创建

最简单的方法就是把一个列表生成式的 [] 改成 ()

- 创建 List 和 generator 的区别仅在于最外层的 [] 和 () 
- 但是生成器并不真正创建数字列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生” ( yield ) 出来。

  ```python
  gen= (x * x for x in range(10))
  print(gen)
  ```

- 输出结果

  ```
  <generator object <genexpr> at 0x0000000002734A40>
  ```

### 生成器的运用

- 遍历生成器的元素：使用 for 循环或者 `next()`

  ```python
  gen= (x * x for x in range(10))

  for num  in  gen :
    print(num)
  ```

- 以函数的形式实现生成器：<mark>使用 `yield`</mark>
  - 实际运用中，大多数的生成器都是通过函数来实现的
  - 生成器的最好的应用是：不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。因为这样会耗很大的资源
- generator 和函数的执行流程不一样：
  - 函数是顺序执行，遇到 `return` 语句或者最后一行函数语句就返回。
  - <mark>而变成 generator 的函数，在每次调用 `next()` 的时候执行，遇到 `yield` 语句返回，再次执行时从上次返回的 `yield` 语句处继续执行。</mark>
- 示例1：计算斐波那契数列的生成器：；运行大的参数也不会使用太多的资源

  ```python
  def fibon(n):
      a = b = 1
      for i in range(n):
          yield a
          a, b = b, a + b

  # 引用函数
  for x in fibon(1000000):
      print(x , end = ' ')
  ```

- 示例2：打印杨辉三角<mark>（没看懂）</mark>

  ```python
  # -*- coding: UTF-8 -*-
  def triangles( n ):         # 杨辉三角形
      L = [1]
      while True:
          yield L
          L.append(0)
          L = [ L [ i -1 ] + L [ i ] for i in range (len(L))]

  n= 0
  for t in triangles( 10 ):   # 直接修改函数名即可运行
      print(t)
      n = n + 1
      if n == 10:
          break
  ```
  - 打印输出结果：

    ```
    [1]
    [1, 1]
    [1, 2, 1]
    [1, 3, 3, 1]
    [1, 4, 6, 4, 1]
    [1, 5, 10, 10, 5, 1]
    [1, 6, 15, 20, 15, 6, 1]
    [1, 7, 21, 35, 35, 21, 7, 1]
    [1, 8, 28, 56, 70, 56, 28, 8, 1]
    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
    ```


